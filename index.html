<!DOCTYPE html>
<!-- HTML HEAD Module ---------------------------------------------------------------------------------------------------------------->
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Geodesic Sphere Depth Visualizer</title>
  <style>
    body {
      font-family: sans-serif;
    }

    #controls {
      width: 250px;
      padding: 20px;
      height: 100vh;
      background: #eee;
      box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: fixed;
      right: 0;
      margin-left: 80vw;
    }

    .menu {
      display: flex;
      max-width: 100vw;
    }

    canvas {
      flex: 1;
    }

    label {
      font-weight: bold;
    }
  </style>
</head>

<body>
  <!-- HTML HEAD Module ends---------------------------------------------------------------------------------------------------------------->
  <!-- DIV Module -------------------------------------------------------------------------------------------------------------------------->
  <!-- Right SIDEBAR CONTROL PANEL -->

  <div class="menu">

    <div id="controls">
      <label for="bgColor">Background Color:</label>
      <input type="color" id="bgColor" value="#ffffff" />

      <label for="gridColor">Grid Line Color:</label>
      <input type="color" id="gridColor" value="#000000" />

      <label for="spinToggle">
        <input type="checkbox" id="spinToggle" checked /> Spin Sphere
      </label>

      <label for="">Cap Radius:</label>
      <input type="number" id="capSize" value="1.0" min="0.1" max="3" step="0.1" />

      <label for="capHeight">Cap Anchor Y:</label>
      <input type="number" id="capHeight" value="5.3" min="-10" max="10" step="0.1" />

      <label for="capDirection">Cap Direction:</label>
      <select id="capDirection">
        <option value="0">North</option>
        <option value="45">NE</option>
        <option value="90">East</option>
        <option value="135">SE</option>
        <option value="180">South</option>
        <option value="225">SW</option>
        <option value="270">West</option>
        <option value="315">NW</option>
      </select>

    </div>
    <!-- DIV Module ends -------------------------------------------------------------------------------------------->
    <!---  ----------------------------------------------SCRIPT Modules --------------------------------------------->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/controls/OrbitControls.js"></script>
    <script>
      // --- INITIAL SCENE SETUP ---
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, (window.innerWidth - 250) / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth - 250, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // --- ORBIT CONTROLS FOR MOUSE ROTATION ---
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enablePan = false;
      controls.enableZoom = false;
      controls.rotateSpeed = 0.4;
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      camera.position.set(0, 0, 15);
      camera.lookAt(new THREE.Vector3(0, 0, 0));
      controls.enableZoom = true;
      controls.enablePan = true;

      // --- Define Outer Radius for curvature matching ---
      const outerRadius = 5;

      // --- GLOBAL STATE FOR AUTO-SPIN ---
      let isSpinning = true;

      // --- get variable values for sphere cap demensions ---
      let capRadius = parseFloat(document.getElementById('capSize').value);
      let capHeight = parseFloat(document.getElementById('capHeight').value);
      const capSegments = 32;
      const gridColor = document.getElementById('gridColor').value;

      // --- Create Grid Sphere Material Factory ---
      function createGridMaterial(opacity) {
        return new THREE.MeshBasicMaterial({
          color: gridColor,
          wireframe: true,
          transparent: true,
          opacity: opacity
        });
      }

      // --- Create Outer Grid Sphere ---
      const outerRadius = 5;
      const outerSphere = new THREE.Mesh(
        new THREE.IcosahedronGeometry(outerRadius, 4),
        createGridMaterial(1.0)
      );
      scene.add(outerSphere);

      // --- Create Inner Grid Sphere ---
      const innerSphereRadius = outerRadius - 0.15;
      innerSphere = new THREE.Mesh(
        new THREE.IcosahedronGeometry(innerSphereRadius, 4),
        createGridMaterial(0.6)
      );
      scene.add(innerSphere);


      // --- CREATE FOG SHELL (BLEND OF GRID + BACKGROUND COLORS) ---
      let bgColor = document.getElementById('bgColor').value;
      const fogColor = new THREE.Color(gridColor).lerp(new THREE.Color(bgColor), 0.5);
      const fogGeometry = new THREE.SphereGeometry(4.6, 64, 64);
      const fogMaterial = new THREE.MeshBasicMaterial({
        color: fogColor,
        transparent: true,
        opacity: 0.5
      });
      const fogShell = new THREE.Mesh(fogGeometry, fogMaterial);
      scene.add(fogShell);
      scene.background = new THREE.Color(bgColor);
      // --- Update fog layer blend  ---
      const updatedFogColor = new THREE.Color(gridColor).lerp(new THREE.Color(bgColor), 0.5);
      fogMaterial.color = updatedFogColor;


      // ---  -----------------------------EVENT LISTENERS FOR UI CONTROLS---------------------------------- ---


      document.getElementById('bgColor').addEventListener('input', e => {
        bgColor = e.target.value;
        scene.background = new THREE.Color(bgColor);
        const updatedFogColor = new THREE.Color(gridColor).lerp(new THREE.Color(bgColor), 0.5);
        fogMaterial.color = updatedFogColor;
      });
      document.getElementById('gridColor').addEventListener('input', e => {
        gridColor = e.target.value;
        outerMaterial.color.set(gridColor);
        innerMaterial.color.set(gridColor);
        // Recalculate fog layer blend
        const updatedFogColor = new THREE.Color(gridColor).lerp(new THREE.Color(bgColor), 0.5);
        fogMaterial.color = updatedFogColor;
      });
      document.getElementById('capSize').addEventListener('input', () => {
        rebuildCap(getCurrentUIValues());
      });
      document.getElementById('capHeight').addEventListener('input', () => {
        rebuildCap(getCurrentUIValues());
      });
      document.getElementById('capDirection').addEventListener('input', () => {
        rebuildCap(getCurrentUIValues());
      });
      document.getElementById('spinToggle').addEventListener('change', e => {
        isSpinning = e.target.checked;
      });

      // --- ------------------------------------Beginning of Cap Creation----------------------------------- ---

      // --- Build Cap Function ---
      function createDirectionalCap({ radius, height, headingDeg }) {
        const outerRadius = 5;
        const phiLength = THREE.MathUtils.clamp(radius / outerRadius, 0.05, 0.3);
        const capSegments = 32;

        // --- Geometry & Material ---
        const capGeometry = new THREE.SphereGeometry(radius, capSegments, capSegments, 0, Math.PI * 2, 0, phiLength);
        const capMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.7 });
        const cap = new THREE.Mesh(capGeometry, capMaterial);

        // --- Surface Anchor ---
        const surfaceNormal = new THREE.Vector3(0, height, 0).normalize();
        const anchorY = outerRadius + height;
        cap.position.copy(surfaceNormal.clone().multiplyScalar(anchorY));
        cap.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), surfaceNormal);

        // --- Direction Calculation ---
        const headingRad = THREE.MathUtils.degToRad(headingDeg);
        const upVector = new THREE.Vector3(0, 1, 0);
        const right = new THREE.Vector3().crossVectors(upVector, surfaceNormal).normalize();
        const forward = new THREE.Vector3().crossVectors(surfaceNormal, right).normalize();
        const directionVector = forward.clone().applyAxisAngle(surfaceNormal, headingRad);

        // --- Direction Line Indicator ---
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff });
        const points = [
          new THREE.Vector3(0, 0, 0),
          directionVector.clone().multiplyScalar(radius * 0.9)
        ];
        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
        const headingLine = new THREE.Line(lineGeometry, lineMaterial);
        cap.add(headingLine);

        scene.add(cap);
        return cap;
      }
      // --- UI Value Fetcher ---
      function getCurrentUIValues() {
        return {
          radius: parseFloat(document.getElementById('capSize').value),
          height: parseFloat(document.getElementById('capHeight').value),
          headingDeg: parseFloat(document.getElementById('capDirection').value)
        };
      }

      // --- Rebuild Handler ---
      function rebuildCap(params) {
        const existingCap = scene.getObjectByName('directionalCap');
        if (existingCap) scene.remove(existingCap);

        const newCap = createDirectionalCap(params);
        newCap.name = 'directionalCap';
      }


      rebuildCap(getCurrentUIValues());
      // --- ------------------------------------End of Cap Management-------------------------------------- ---

      // --- MAIN ANIMATION LOOP ---
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        if (isSpinning) {
          outerSphere.rotation.y += 0.002;
          innerSphere.rotation.y += 0.002;
          fogShell.rotation.y += 0.002;
        }
        renderer.render(scene, camera);
      }
      scene.background = new THREE.Color(bgColor);
      animate();
    </script>
  </div>
</body>

</html>
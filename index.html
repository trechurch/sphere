<!DOCTYPE html>
<html lang="en">    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wireframe Sphere with Modular Caps</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #gui { position: absolute; top: 10px; right: 10px; }
    </style>
</head>
<body>
    <div id="gui"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Scene setup
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Camera controls
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Icosahedron setup for triangular wireframe
            const sphereRadius = 5;
            const geometry = new THREE.IcosahedronGeometry(sphereRadius, 2);
            const edges = new THREE.EdgesGeometry(geometry);
            const sphereMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
            const sphere = new THREE.LineSegments(edges, sphereMaterial);
            scene.add(sphere);

            // Modular caps data with scale states
            let caps = [
                {
                    x: 0,
                    y: 3,
                    z: 0,
                    size: 1,
                    height: 0,
                    direction: 'N',
                    mesh: null,
                    xScale: 5,
                    yScale: 5,
                    zScale: 5,
                    sizeScale: 5
                }
            ];

            // Scale factors
            const scaleFactors = [0.01, 0.05, 0.1, 0.5, 1];
            const scaleLabels = [1, 2, 3, 4, 5];

            // Directions for dropdown
            const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];

            // GUI setup
            const gui = new dat.GUI({ autoPlace: false });
            document.getElementById('gui').appendChild(gui.domElement);
            const settings = {
                backgroundColor: '#000000',
                wireframeColor: '#00ff00',
                rotateSphere: false
            };

            // Cap creation function
            function createCap(cap) {
                if (cap.mesh) scene.remove(cap.mesh);
                const lat = Math.asin(cap.y / sphereRadius) * 180 / Math.PI;
                const lon = Math.atan2(cap.x, Math.sqrt(sphereRadius * sphereRadius - cap.x * cap.x - cap.y * cap.y)) * 180 / Math.PI;
                const capGeometry = new THREE.SphereGeometry(sphereRadius + cap.height, 32, 16, 0, Math.PI * 2, 0, cap.size * Math.PI / 6);
                const capEdges = new THREE.EdgesGeometry(capGeometry);
                const capMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
                const capMesh = new THREE.LineSegments(capEdges, capMaterial);

                // Position cap
                capMesh.position.set(0, 0, 0);
                capMesh.rotation.set(0, -lon * Math.PI / 180, -lat * Math.PI / 180);

                // Directional indicator
                const arrowGeometry = new THREE.BufferGeometry();
                const vertices = new Float32Array([
                    0, 0, sphereRadius + cap.height,
                    0, 0, sphereRadius + cap.height + 0.5
                ]);
                arrowGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                const arrow = new THREE.Line(arrowGeometry, new THREE.LineBasicMaterial({ color: 0xffff00 }));
                const angle = directions.indexOf(cap.direction) * 45 * Math.PI / 180;
                arrow.rotation.z = angle;
                capMesh.add(arrow);

                cap.mesh = capMesh;
                scene.add(capMesh);
            }

            // Update all caps
            function updateCaps() {
                caps.forEach(cap => createCap(cap));
            }

            // GUI controls
            gui.addColor(settings, 'backgroundColor').onChange(value => {
                scene.background = new THREE.Color(value);
            });
            gui.addColor(settings, 'wireframeColor').onChange(value => {
                sphereMaterial.color.set(value);
            });
            gui.add(settings, 'rotateSphere').onChange(value => {
                sphere.userData.rotate = value;
            });

            // Cap folder
            const capFolder = gui.addFolder('Caps');
            let capControllers = [];

            function updateCapGUI() {
                // Clear existing controllers
                capControllers.forEach(ctrl => capFolder.removeFolder(ctrl));
                capControllers = [];

                caps.forEach((cap, index) => {
                    const folder = capFolder.addFolder(`Cap ${index + 1}`);
                    capControllers.push(folder);

                    // X Coordinate with scale
                    folder.add(cap, 'x', -sphereRadius, sphereRadius, 1).name('X Coordinate').onChange(value => {
                        cap.x = value * scaleFactors[cap.xScale - 1];
                        updateCaps();
                    });
                    folder.add({ xScale: () => {
                        cap.xScale = (cap.xScale % 5) + 1;
                        cap.x = cap.x * scaleFactors[cap.xScale - 1] / (scaleFactors[(cap.xScale - 2 + 5) % 5] || 1);
                        updateCapGUI();
                        updateCaps();
                    }}, 'xScale').name(`X Scale (${cap.xScale})`);

                    // Y Coordinate with scale
                    folder.add(cap, 'y', -sphereRadius, sphereRadius, 1).name('Y Coordinate').onChange(value => {
                        cap.y = value * scaleFactors[cap.yScale - 1];
                        updateCaps();
                    });
                    folder.add({ yScale: () => {
                        cap.yScale = (cap.yScale % 5) + 1;
                        cap.y = cap.y * scaleFactors[cap.yScale - 1] / (scaleFactors[(cap.yScale - 2 + 5) % 5] || 1);
                        updateCapGUI();
                        updateCaps();
                    }}, 'yScale').name(`Y Scale (${cap.yScale})`);

                    // Z Coordinate (Height) with scale
                    folder.add(cap, 'z', 0, sphereRadius * 2, 1).name('Height').onChange(value => {
                        cap.height = value * scaleFactors[cap.zScale - 1];
                        cap.z = cap.height;
                        updateCaps();
                    });
                    folder.add({ zScale: () => {
                        cap.zScale = (cap.zScale % 5) + 1;
                        cap.height = cap.z * scaleFactors[cap.zScale - 1] / (scaleFactors[(cap.zScale - 2 + 5) % 5] || 1);
                        cap.z = cap.height;
                        updateCapGUI();
                        updateCaps();
                    }}, 'zScale').name(`Z Scale (${cap.zScale})`);

                    // Size with scale
                    folder.add(cap, 'size', 0.1, 2, 0.1).name('Size').onChange(value => {
                        cap.size = value * scaleFactors[cap.sizeScale - 1];
                        updateCaps();
                    });
                    folder.add({ sizeScale: () => {
                        cap.sizeScale = (cap.sizeScale % 5) + 1;
                        cap.size = cap.size * scaleFactors[cap.sizeScale - 1] / (scaleFactors[(cap.sizeScale - 2 + 5) % 5] || 1);
                        updateCapGUI();
                        updateCaps();
                    }}, 'sizeScale').name(`Size Scale (${cap.sizeScale})`);

                    // Direction
                    folder.add(cap, 'direction', directions).name('Direction').onChange(updateCaps);

                    // Remove cap
                    folder.add({ removeCap: () => {
                        scene.remove(cap.mesh);
                        caps.splice(index, 1);
                        updateCapGUI();
                    }}, 'removeCap').name(`Remove Cap ${index + 1}`);
                });

                // Add new cap button
                capFolder.add({ addCap: () => {
                    caps.push({
                        x: Math.random() * sphereRadius * 0.5,
                        y: Math.random() * sphereRadius * 0.5,
                        z: 0,
                        size: 1,
                        height: 0,
                        direction: 'N',
                        mesh: null,
                        xScale: 5,
                        yScale: 5,
                        zScale: 5,
                        sizeScale: 5
                    });
                    updateCapGUI();
                    updateCaps();
                }}, 'addCap').name('Add New Cap');
            }

            updateCapGUI();

            // Camera position
            camera.position.z = 15;

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                if (sphere.userData.rotate) {
                    sphere.rotation.y += 0.01;
                }
                controls.update();
                renderer.render(scene, camera);
            }
            animate();

            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        });
    </script>
</body>
</html>
<!DOCTYPE html>
<!-- HTML HEAD Module ---------------------------------------------------------------------------------------------------------------->
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Geodesic Sphere Depth Visualizer</title>
  <style>
    body {
      font-family: sans-serif;
    }

    #controls {
      width: 250px;
      padding: 20px;
      height: 100vh;
      background: #eee;
      box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: fixed;
      right: 0;
      margin-left: 80vw;
    }

    .menu {
      display: flex;
      max-width: 100vw;
    }

    canvas {
      flex: 1;
    }

    label {
      font-weight: bold;
    }
  </style>
</head>

<body>
  <!-- HTML HEAD Module ends---------------------------------------------------------------------------------------------------------------->
  <!-- DIV Module -------------------------------------------------------------------------------------------------------------------------->
  <!-- LEFT SIDEBAR CONTROL PANEL -->

  <div class="menu">

    <div id="controls">
      <label for="bgColor">Background Color:</label>
      <input type="color" id="bgColor" value="#ffffff" />

      <label for="gridColor">Grid Line Color:</label>
      <input type="color" id="gridColor" value="#000000" />

      <label for="spinToggle">
        <input type="checkbox" id="spinToggle" checked /> Spin Sphere
      </label>

      <label for="">Cap Radius:</label>
      <input type="number" id="capSize" value="1.0" min="0.1" max="3" step="0.1" />

      <label for="capHeight">Cap Anchor Y:</label>
      <input type="number" id="capHeight" value="5.3" min="-10" max="10" step="0.1" />

      <label for="capDirection">Cap Direction:</label>
      <select id="capDirection">
        <option value="0">North</option>
        <option value="45">NE</option>
        <option value="90">East</option>
        <option value="135">SE</option>
        <option value="180">South</option>
        <option value="225">SW</option>
        <option value="270">West</option>
        <option value="315">NW</option>
      </select>

    </div>
    <!-- DIV Module ends ---------------------------------------------------------------------------------------------------------------------->
    <!-- SCRIPT Modules ----------------------------------------------------------------------------------------------------------------------->
    <!-- THREE.JS & ORBITCONTROLS LIBRARIES --------------------------------------------------------------------------------------------------->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/controls/OrbitControls.js"></script>
    <!-- Visuals Module ------------------------------------------------------------------------------------------------------------------------->
    <script>
      // --- INITIAL SCENE SETUP ---
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, (window.innerWidth - 250) / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth - 250, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      // --- ORBIT CONTROLS FOR MOUSE ROTATION ---
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enablePan = false;
      controls.enableZoom = false;
      controls.rotateSpeed = 0.4;
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      camera.position.set(0, 0, 15);
      camera.lookAt(new THREE.Vector3(0, 0, 0));
      controls.enableZoom = true;
      controls.enablePan = true;
      // --- GLOBAL STATE FOR AUTO-SPIN ---
      let isSpinning = true;
      document.getElementById('spinToggle').addEventListener('change', e => {
        isSpinning = e.target.checked;
      });
      // --- get variable values for sphere cap demensions ---
      let capRadius = parseFloat(document.getElementById('capSize').value);
      let capHeight = parseFloat(document.getElementById('capHeight').value);
      const capSegments = 32;

      // --- CREATE OUTER GRID SPHERE ---
      let gridColor = document.getElementById('gridColor').value;
      const outerGeometry = new THREE.IcosahedronGeometry(5, 4);
      const outerMaterial = new THREE.MeshBasicMaterial({
        color: gridColor,
        wireframe: true,
        transparent: true,
        opacity: 1.0
      });
      const outerSphere = new THREE.Mesh(outerGeometry, outerMaterial);
      scene.add(outerSphere);
      // --- CREATE INNER GRID SPHERE ---
      const innerGeometry = new THREE.IcosahedronGeometry(4.85, 4);
      const innerMaterial = new THREE.MeshBasicMaterial({
        color: gridColor,
        wireframe: true,
        transparent: true,
        opacity: 0.6
      });
      const innerSphere = new THREE.Mesh(innerGeometry, innerMaterial);
      scene.add(innerSphere);
      // --- CREATE FOG SHELL (BLEND OF GRID + BACKGROUND COLORS) ---
      let bgColor = document.getElementById('bgColor').value;
      const fogColor = new THREE.Color(gridColor).lerp(new THREE.Color(bgColor), 0.5);
      const fogGeometry = new THREE.SphereGeometry(4.6, 64, 64);
      const fogMaterial = new THREE.MeshBasicMaterial({
        color: fogColor,
        transparent: true,
        opacity: 0.5
      });
      const fogShell = new THREE.Mesh(fogGeometry, fogMaterial);
      scene.add(fogShell);
      scene.background = new THREE.Color(bgColor);
      // --- Update fog layer blend  ---
      const updatedFogColor = new THREE.Color(gridColor).lerp(new THREE.Color(bgColor), 0.5);
      fogMaterial.color = updatedFogColor;
      document.getElementById('bgColor').addEventListener('input', e => {
        bgColor = e.target.value;
        scene.background = new THREE.Color(bgColor);
        const updatedFogColor = new THREE.Color(gridColor).lerp(new THREE.Color(bgColor), 0.5);
        fogMaterial.color = updatedFogColor;
      });
      document.getElementById('gridColor').addEventListener('input', e => {
        gridColor = e.target.value;
        outerMaterial.color.set(gridColor);
        innerMaterial.color.set(gridColor);
        // Recalculate fog layer blend
        const updatedFogColor = new THREE.Color(gridColor).lerp(new THREE.Color(bgColor), 0.5);
        fogMaterial.color = updatedFogColor;
      });
      // --- Define Outer Radius for curvature matching ---
      const outerRadius = 5;

      // --- Create Cap Material Once ---
      const capMaterial = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        transparent: true,
        opacity: 0.7
      });
      // --- Create Initial Cap Geometry ---
      let phiLength = THREE.MathUtils.clamp(capRadius / outerRadius, 0.05, 0.3);
      let capGeometry = new THREE.SphereGeometry(
        capRadius,
        capSegments,
        capSegments,
        0,
        Math.PI * 2,
        0,
        phiLength
      );
      
      // --- Create Cap Mesh & Position ---
      const cap = new THREE.Mesh(capGeometry, capMaterial);
      const surfaceNormal = new THREE.Vector3(0, capHeight, 0).normalize();
      const anchorY = outerRadius + capHeight; // capHeight becomes surface offset
      cap.position.copy(surfaceNormal.clone().multiplyScalar(anchorY));

      // --- SPINNING STATE ---  
      const degrees = parseFloat(document.getElementById('capDirection').value);
      const radians = THREE.MathUtils.degToRad(degrees);
      const directionVector = new THREE.Vector3(Math.sin(radians), 0, Math.cos(radians)).normalize();

      // --- Create Direction Vector ---
      const dirGeometry = new THREE.ConeGeometry(0.2, 0.5, 16);
      const dirMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      const dirMarker = new THREE.Mesh(dirGeometry, dirMaterial);

      dirMarker.position.copy(directionVector.clone().multiplyScalar(capRadius));
      dirMarker.lookAt(new THREE.Vector3(0, 0, 0));
      cap.add(dirMarker); // Attach to cap

      // Align cap to surface normal
      cap.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), surfaceNormal);
      console.log('Cap created at:', cap.position.toArray());
      scene.add(new THREE.AxesHelper(2)); // To visualize orientation
      console.log('Cap created at:', cap.position.toArray());
      scene.add(new THREE.AxesHelper(2)); // To visualize orientation
      scene.add(cap);
      // --- Modular Update Function ---
      function updateCap() {
        capRadius = parseFloat(document.getElementById('capSize').value);
        capHeight = parseFloat(document.getElementById('capHeight').value);
        phiLength = THREE.MathUtils.clamp(capRadius / outerRadius, 0.05, 0.3);
        cap.geometry.dispose();
        cap.geometry = new THREE.SphereGeometry(
          capRadius,
          capSegments,
          capSegments,
          0,
          Math.PI * 2,
          0,
          phiLength
        );
        const surfaceNormal = new THREE.Vector3(0, capHeight, 0).normalize();
        cap.position.copy(surfaceNormal.clone().multiplyScalar(capHeight));
        cap.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), surfaceNormal);
      }
      // --- UI Listeners for Cap Adjustments ---
      document.getElementById('capHeight').addEventListener('input', e => {
        capHeight = parseFloat(e.target.value);
        updateCap();
      });
      console.log('Cap radius:', capRadius);
      console.log('Phi length:', phiLength);
      console.log('Cap position:', cap.position.toArray());
      console.log('Cap height:', capHeight);
      console.log('Cap visible:', cap.visible);
      document.getElementById('capSize').addEventListener('input', e => {
        capRadius = parseFloat(e.target.value);
        const debugMarker = new THREE.Mesh()
        debugMarker.position.copy(cap.position);
        updateCap();
      });
      // --- HANDLE WINDOW RESIZE ---
      window.addEventListener('resize', () => {
        camera.aspect = (window.innerWidth - 250) / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth - 250, window.innerHeight);
        updateCap();
      });

      const debugMarker = new THREE.Mesh(
        new THREE.SphereGeometry(0.1, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0x00ffff })
      );
      scene.add(debugMarker);
      // --- MAIN ANIMATION LOOP ---
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        if (isSpinning) {
          outerSphere.rotation.y += 0.002;
          innerSphere.rotation.y += 0.002;
          fogShell.rotation.y += 0.002;
        }
        renderer.render(scene, camera);
      }
      scene.background = new THREE.Color(bgColor);
      animate();
    </script>
  </div>
</body>

</html>
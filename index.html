<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wireframe Sphere with Modular Caps</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #gui { position: absolute; top: 10px; right: 10px; }
    </style>
</head>
<body>
    <div id="gui"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Scene setup
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Camera controls
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Icosahedron setup for triangular wireframe
            const sphereRadius = 5;
            const geometry = new THREE.IcosahedronGeometry(sphereRadius, 2);
            const edges = new THREE.EdgesGeometry(geometry);
            const sphereMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
            const sphere = new THREE.LineSegments(edges, sphereMaterial);
            scene.add(sphere);

            // Modular caps data
            let caps = [
                {
                    x: 0,
                    y: 3,
                    z: 0,
                    size: 1,
                    height: 0,
                    direction: 'N',
                    xScaler: 5,
                    yScaler: 5,
                    zScaler: 5,
                    sizeScaler: 5,
                    mesh: null
                }
            ];

            // Scaler values
            const scalerValues = [0.01, 0.05, 0.1, 0.5, 1];
            const scalerLabels = ['1 (0.01x)', '2 (0.05x)', '3 (0.1x)', '4 (0.5x)', '5 (1x)'];

            // Directions for dropdown
            const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];

            // GUI setup
            const gui = new dat.GUI({ autoPlace: false });
            document.getElementById('gui').appendChild(gui.domElement);
            const settings = {
                backgroundColor: '#000000',
                wireframeColor: '#00ff00',
                rotateSphere: false
            };

            // Cap creation function
            function createCap(cap) {
                if (cap.mesh) scene.remove(cap.mesh);

                // Apply scalers
                let scaledX = cap.x * scalerValues[cap.xScaler - 1];
                let scaledY = cap.y * scalerValues[cap.yScaler - 1];
                const scaledHeight = Math.max(0, cap.z * scalerValues[cap.zScaler - 1]);
                const scaledSize = Math.max(0.1, cap.size * scalerValues[cap.sizeScaler - 1]);

                // Clamp X, Y to ensure valid spherical coordinates
                const maxRadius = sphereRadius * 0.999; // Slight margin to avoid edge cases
                const distance = Math.sqrt(scaledX * scaledX + scaledY * scaledY);
                if (distance > maxRadius) {
                    const scale = maxRadius / distance;
                    scaledX *= scale;
                    scaledY *= scale;
                }

                // Compute spherical coordinates
                const lat = Math.asin(scaledY / sphereRadius) * 180 / Math.PI;
                const lon = Math.atan2(scaledX, Math.sqrt(Math.max(0, sphereRadius * sphereRadius - scaledX * scaledX - scaledY * scaledY))) * 180 / Math.PI;

                // Create cap geometry
                const capGeometry = new THREE.SphereGeometry(sphereRadius + scaledHeight, 32, 16, 0, Math.PI * 2, 0, scaledSize * Math.PI / 6);
                const capEdges = new THREE.EdgesGeometry(capGeometry);
                const capMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
                const capMesh = new THREE.LineSegments(capEdges, capMaterial);

                // Position cap
                capMesh.position.set(0, 0, 0);
                capMesh.rotation.set(0, -lon * Math.PI / 180, -lat * Math.PI / 180);

                // Directional indicator
                const arrowGeometry = new THREE.BufferGeometry();
                const vertices = new Float32Array([
                    0, 0, sphereRadius + scaledHeight,
                    0, 0, sphereRadius + scaledHeight + 0.5
                ]);
                arrowGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                const arrow = new THREE.Line(arrowGeometry, new THREE.LineBasicMaterial({ color: 0xffff00 }));
                const angle = directions.indexOf(cap.direction) * 45 * Math.PI / 180;
                arrow.rotation.z = angle;
                capMesh.add(arrow);

                cap.mesh = capMesh;
                scene.add(capMesh);
            }

            // Update all caps
            function updateCaps() {
                caps.forEach(cap => createCap(cap));
            }

            // GUI controls
            gui.addColor(settings, 'backgroundColor').onChange(value => {
                scene.background = new THREE.Color(value);
            });
            gui.addColor(settings,'wireframeColor').onChange(value => {
                sphereMaterial.color.set358(value);
            });
            gui.add(settings, 'rotateSphere').onChange(value => {
                sphere.userData.rotate = value;
            });

            // Cap folder
            const capFolder = gui.addFolder('Caps');
            let capControllers = [];

            function updateCapGUI() {
                // Clear existing controllers revistas
                capControllers.forEach(ctrl => capFolder.removeFolder(ctrl));
                capControllers = [];

                caps.forEach((cap, index) => {
                    const folder = capFolder.addFolder(`Cap ${index + 1}`);
                    capControllers.push(folder);
                    folder.add(cap, 'x', -sphereRadius, sphereRadius, 1).name('X Coordinate').onChange(updateCaps);
                    folder.add(cap, 'xScaler', scalerLabels).name(' Yor Scaler').onChange(updateCaps);
                    folder.add(cap, 'y', -sphereRadius, sphereRadius, 1).name('Y Coordinate').onChange(updateCaps);
                    folder.add(cap, 'yScaler', scalerLabels).name('Y Scaler').onChange(updateCaps);
                    folder.add(cap, 'z', 0, sphereRadius * 2, 1).name('Height').onChange(value => {
                        cap.height = value;
                        updateCaps();
                    });
                    folder.add(cap, 'zScaler', scalerLabels).name('Height Scaler').onChange(updateCaps);
                    folder.add(cap, 'size', 0.1, 2, 1).name('Size').onChange(updateDefiniteCaps);
                    folder.add(cap, 'sizeScaler', scalerLabels).name('Size Scaler').onChange(updateCaps);
                    folder.add(cap, 'direction', directions).name('Direction').onChange(updateCaps);
                    folder.add({ removeCap: () => {
                        scene.remove(cap.mesh);
                        caps.splice(index, 1);
                        updateCapGUI();
                    }}, 'removeCap').name(`Remove Cap ${index + 1}`);
                });

                // Add new cap button
                capFolder.add({ addCap: () => {
                    caps.push({
                        x: Math.random() * sphereRadius * 0.5,
                        y: Math.random() * sphereRadius * 0.5,
                        z: 0,
                        size: 1,
                        height: 0,
                        direction: 'N',
                        xScaler: 5,
                        yScaler: 5,
                        zScaler: 5,
                        sizeScaler: 5,
                        mesh: null
                    });
                    updateCapGUI();
                    updateCaps();
                }}, 'addCap').name('Add New Cap');
            }

            updateCapGUI();

            // Camera position
            camera.position.z = 15;

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                if (sphere.userData.rotate) {
                    sphere.rotation.y += 0.01;
                }
                controls.update();
                renderer.render(scene, camera);
            }
            animate();

            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect= window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        });
    </script>
</body>
</html>